package sp.pipeline.scorecalculators.components.heuristic;

import lombok.Getter;
import org.apache.flink.api.common.functions.RichMapFunction;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeHint;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.configuration.Configuration;
import sp.dtos.AISSignal;
import sp.dtos.AnomalyInformation;
import sp.dtos.Timestamp;

@Getter
public abstract class HeuristicStatefulMapFunction extends RichMapFunction<AISSignal, AnomalyInformation> {

    /*
        We have three value states, one for last processed aisSignal, one for the
        one for last processed anomaly information and one for the last time when
        we have detected an anomaly.
     */
    private transient ValueState<AnomalyInformation> anomalyInformationValueState;
    private transient ValueState<AISSignal> aisSignalValueState;
    private transient ValueState<Timestamp> lastDetectedAnomalyTime;

    @Override
    public void open(Configuration config) {

        // Setup the state descriptors
        ValueStateDescriptor<Timestamp> lastDetectedAnomalyTimeDescriptor =
                new ValueStateDescriptor<>(
                        "time",
                        TypeInformation.of(new TypeHint<Timestamp>() {})
                );

        ValueStateDescriptor<AISSignal> aisSignalValueStateDescriptor =
                new ValueStateDescriptor<>(
                        "AIS",
                        TypeInformation.of(new TypeHint<AISSignal>() {})
                );

        ValueStateDescriptor<AnomalyInformation> anomalyInformationValueStateDescriptor =
                new ValueStateDescriptor<>(
                        "anomaly",
                        TypeInformation.of(new TypeHint<AnomalyInformation>() {})
                );

        // Initialize the states and set them to be accessible in the map function
        lastDetectedAnomalyTime = getRuntimeContext().getState(lastDetectedAnomalyTimeDescriptor);
        aisSignalValueState = getRuntimeContext().getState(aisSignalValueStateDescriptor);
        anomalyInformationValueState = getRuntimeContext().getState(anomalyInformationValueStateDescriptor);
    }

    /**
     * Logic for setting the result of the anomaly detected by each heuristic.
     *
     * @param anomalyInformation - the object that we are updating
     * @param value - the AIS signal that was processed
     * @param anomalyScore - the score that each heuristic can set
     * @param badMsg - the explanation in case of anomaly
     * @param goodMsg - the message in case that it is not an anomaly
     * @return the computed AnomalyInformation
     * @throws Exception - Exception generated by the getValue() of the stateDescriptors, probably should be caught :D
     */
    public AnomalyInformation setAnomalyInformationResult(AnomalyInformation anomalyInformation, AISSignal value,
                                            Float anomalyScore, String badMsg, String goodMsg) throws Exception {
        anomalyInformation.setShipHash(value.getShipHash());
        anomalyInformation.setCorrespondingTimestamp(value.getTimestamp());
        // The AIS signal is considered an anomaly only if the difference between the current time and the last detected anomaly
        // time is less than 30 minutes
        if (getLastDetectedAnomalyTime().value() != null
            && value.getTimestamp().difference(getLastDetectedAnomalyTime().value()) <= 30) {
            anomalyInformation.setScore(anomalyScore);
            anomalyInformation.setExplanation(badMsg);
        } else {
            anomalyInformation.setScore(0f);
            anomalyInformation.setExplanation(goodMsg);
        }
        getAnomalyInformationValueState().update(anomalyInformation);
        getAisSignalValueState().update(value);
        return anomalyInformation;
    }

}
